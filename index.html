<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laser Eyes AR - Three.js & MediaPipe</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #input_video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); 
            z-index: 0;
        }

        #output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            transform: scaleX(-1);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff00;
            font-size: 24px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border: 1px solid #00ff00;
            border-radius: 8px;
            z-index: 10;
            text-align: center;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            display: flex;
            gap: 10px;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
        }

        button {
            background: #ff0000;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            box-shadow: 0 0 15px #ff0000;
            text-transform: uppercase;
        }
        
        button:hover {
            background: #cc0000;
        }
        
        select {
            background: #333;
            color: white;
            border: 1px solid #666;
            padding: 10px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
        }

        .hidden {
            display: none !important;
        }
    </style>
    
    <!-- MediaPipe Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    
    <!-- Three.js Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>

    <div id="container">
        <video id="input_video" playsinline></video>
        <canvas id="output_canvas"></canvas>
        
        <div id="loading">
            INITIALIZING SYSTEM...<br>
            <span style="font-size: 14px; color: #aaa;">(Please allow camera access)</span>
        </div>

        <div id="controls" class="hidden">
            <button id="toggleBtn">Toggle Effect</button>
            <select id="effectSelector">
                <option value="none">None</option>
                <option value="laser">Laser Eyes</option>
                <option value="fire">Flame Eyes</option>
                <option value="tears">Tears</option>
            </select>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- Configuration ---
        const LANDMARK_IDS = {
            LEFT_EYE: 468,  
            RIGHT_EYE: 473, 
            LEFT_TEAR_START: 160, 
            RIGHT_TEAR_START: 387, 
            NOSE_TIP: 1,
            FOREHEAD: 10,
            CHIN: 152,
            LEFT_CHEEK: 234,
            RIGHT_CHEEK: 454
        };

        // --- State ---
        const state = {
            effectEnabled: false,
            currentEffect: 'none', 
            isLoaded: false,
            lastFrameTime: performance.now() // Initialize correctly
        };

        // --- DOM Elements ---
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const loadingElement = document.getElementById('loading');
        const controlsElement = document.getElementById('controls');
        const toggleBtn = document.getElementById('toggleBtn');
        const effectSelector = document.getElementById('effectSelector');

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 100;

        const renderer = new THREE.WebGLRenderer({ 
            canvas: canvasElement, 
            alpha: true,
            antialias: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Utility Functions ---
        function createGlowTexture(color = 'red') {
            const glowCanvas = document.createElement('canvas');
            glowCanvas.width = 64;
            glowCanvas.height = 64;
            const ctx = glowCanvas.getContext('2d');
            const grd = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grd.addColorStop(0, `rgba(255, 255, 255, 1)`);
            
            let c = '255, 255, 255';
            if (color === 'red') c = '255, 0, 0';
            if (color === 'blue') c = '0, 100, 255';
            if (color === 'orange') c = '255, 100, 0';

            grd.addColorStop(0.4, `rgba(${c}, 0.5)`);
            grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(glowCanvas);
        }

        const redGlowTexture = createGlowTexture('red');
        const fireParticleTexture = createGlowTexture('orange');
        const tearParticleTexture = createGlowTexture('blue');

        // --- Create Effect Functions ---
        function createLaserEffect() {
            const container = new THREE.Object3D();

            const beamLen = 2000;
            const beamGeo = new THREE.CylinderGeometry(2, 6, beamLen, 8);
            beamGeo.translate(0, beamLen / 2, 0);
            beamGeo.rotateX(-Math.PI / 2);

            const beamMat = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, transparent: true, opacity: 0.6,
                blending: THREE.AdditiveBlending, depthWrite: false
            });
            const beam = new THREE.Mesh(beamGeo, beamMat);
            container.add(beam);

            const coreGeo = new THREE.CylinderGeometry(0.5, 0.5, beamLen, 8);
            coreGeo.translate(0, beamLen / 2, 0);
            coreGeo.rotateX(-Math.PI / 2);
            const coreMat = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, transparent: true, opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            const core = new THREE.Mesh(coreGeo, coreMat);
            container.add(core);

            const spriteMat = new THREE.SpriteMaterial({ 
                map: redGlowTexture, color: 0xff0000, blending: THREE.AdditiveBlending 
            });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(20, 20, 1);
            container.add(sprite);
            
            container.visible = false;
            scene.add(container);
            return container;
        }

        function createParticleSystem(texture, count, type) {
            const particles = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];
            const colors = [];

            for (let i = 0; i < count; i++) {
                positions.push(0, 0, 0);
                if (type === 'fire') {
                    velocities.push(
                        (Math.random() - 0.5) * 0.5,
                        Math.random() * 0.5 + 0.5,
                        (Math.random() - 0.5) * 0.5
                    );
                    colors.push(1.0, Math.random() * 0.6 + 0.4, 0.0, Math.random());
                } else { // tears
                    velocities.push(
                        (Math.random() - 0.5) * 0.2,
                        -Math.random() * 0.8 - 0.5,
                        (Math.random() - 0.5) * 0.2
                    );
                    colors.push(0.5, 0.7, 1.0, Math.random());
                }
            }
            particles.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particles.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));
            particles.setAttribute('color', new THREE.Float32BufferAttribute(colors, 4));

            const material = new THREE.PointsMaterial({
                size: type === 'fire' ? 10 : 6,
                transparent: true,
                blending: type === 'fire' ? THREE.AdditiveBlending : THREE.NormalBlending,
                map: texture,
                vertexColors: true,
                depthWrite: false
            });

            const points = new THREE.Points(particles, material);
            points.visible = false;
            scene.add(points);
            return points;
        }

        function updateParticles(particles, origin, deltaTime, type) {
            if (!particles || !particles.visible) return;

            const positions = particles.geometry.attributes.position.array;
            const velocities = particles.geometry.attributes.velocity.array;
            const colors = particles.geometry.attributes.color.array;
            const count = positions.length / 3;

            // Safety limit for logic loop to prevent hanging if count is huge
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                const i4 = i * 4;

                if (type === 'fire') {
                    positions[i3 + 0] += velocities[i3 + 0] * deltaTime * 60;
                    positions[i3 + 1] += velocities[i3 + 1] * deltaTime * 60;
                    positions[i3 + 2] += velocities[i3 + 2] * deltaTime * 60;
                    colors[i4 + 3] -= 0.04 * deltaTime * 60;

                    if (colors[i4 + 3] <= 0 || positions[i3 + 1] > 40) {
                        positions[i3 + 0] = 0; positions[i3 + 1] = 0; positions[i3 + 2] = 0;
                        velocities[i3 + 0] = (Math.random() - 0.5) * 0.5;
                        velocities[i3 + 1] = Math.random() * 0.5 + 0.5;
                        velocities[i3 + 2] = (Math.random() - 0.5) * 0.5;
                        colors[i4 + 3] = Math.random();
                    }
                } else { // tears
                    velocities[i3 + 1] -= 0.05 * deltaTime * 60; // Gravity
                    positions[i3 + 0] += velocities[i3 + 0] * deltaTime * 60;
                    positions[i3 + 1] += velocities[i3 + 1] * deltaTime * 60;
                    positions[i3 + 2] += velocities[i3 + 2] * deltaTime * 60;
                    colors[i4 + 3] -= 0.02 * deltaTime * 60;

                    if (colors[i4 + 3] <= 0 || positions[i3 + 1] < -60) {
                        positions[i3 + 0] = 0; positions[i3 + 1] = 0; positions[i3 + 2] = 0;
                        velocities[i3 + 0] = (Math.random() - 0.5) * 0.2;
                        velocities[i3 + 1] = -Math.random() * 0.8 - 0.5;
                        velocities[i3 + 2] = (Math.random() - 0.5) * 0.2;
                        colors[i4 + 3] = Math.random();
                    }
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;
            
            // Move the whole system to the eye position
            if (origin) particles.position.copy(origin);
        }

        // --- Instantiate Effects ---
        const leftLaser = createLaserEffect();
        const rightLaser = createLaserEffect();
        
        const leftFlameParticles = createParticleSystem(fireParticleTexture, 100, 'fire');
        const rightFlameParticles = createParticleSystem(fireParticleTexture, 100, 'fire');
        
        const leftTearParticles = createParticleSystem(tearParticleTexture, 50, 'tears');
        const rightTearParticles = createParticleSystem(tearParticleTexture, 50, 'tears');

        // --- Coordinate Mapping ---
        function mapLandmarkToWorld(landmark) {
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const visibleHeight = 2 * Math.tan(vFOV / 2) * camera.position.z;
            const visibleWidth = visibleHeight * camera.aspect;

            return new THREE.Vector3(
                (landmark.x - 0.5) * visibleWidth,
                -(landmark.y - 0.5) * visibleHeight,
                -landmark.z * visibleWidth * 0.5
            );
        }

        // --- Main Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            
            const now = performance.now();
            let deltaTime = (now - state.lastFrameTime) / 1000;
            state.lastFrameTime = now;

            // Prevent huge time steps if tab was backgrounded or just started
            if (deltaTime > 0.1) deltaTime = 0.1;

            if (state.effectEnabled) {
                if (state.currentEffect === 'fire') {
                    updateParticles(leftFlameParticles, null, deltaTime, 'fire');
                    updateParticles(rightFlameParticles, null, deltaTime, 'fire');
                } else if (state.currentEffect === 'tears') {
                    updateParticles(leftTearParticles, null, deltaTime, 'tears');
                    updateParticles(rightTearParticles, null, deltaTime, 'tears');
                }
            }

            renderer.render(scene, camera);
        }
        // Start loop
        animate();

        // --- MediaPipe Logic ---
        function onResults(results) {
            if (!state.isLoaded) {
                state.isLoaded = true;
                loadingElement.classList.add('hidden');
                controlsElement.classList.remove('hidden');
            }
            
            // 1. Hide Everything First
            [leftLaser, rightLaser, leftFlameParticles, rightFlameParticles, leftTearParticles, rightTearParticles].forEach(obj => {
                if(obj) obj.visible = false;
            });

            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];

                // Get Positions
                const leftEyePos = mapLandmarkToWorld(landmarks[LANDMARK_IDS.LEFT_EYE]);
                const rightEyePos = mapLandmarkToWorld(landmarks[LANDMARK_IDS.RIGHT_EYE]);
                const leftTearPos = mapLandmarkToWorld(landmarks[LANDMARK_IDS.LEFT_TEAR_START]);
                const rightTearPos = mapLandmarkToWorld(landmarks[LANDMARK_IDS.RIGHT_TEAR_START]);

                // 2. Show Only Active Effect
                if (state.effectEnabled) {
                    if (state.currentEffect === 'laser') {
                        const cheekL = mapLandmarkToWorld(landmarks[LANDMARK_IDS.LEFT_CHEEK]);
                        const cheekR = mapLandmarkToWorld(landmarks[LANDMARK_IDS.RIGHT_CHEEK]);
                        const forehead = mapLandmarkToWorld(landmarks[LANDMARK_IDS.FOREHEAD]);
                        const chin = mapLandmarkToWorld(landmarks[LANDMARK_IDS.CHIN]);

                        const horizontalVec = new THREE.Vector3().subVectors(cheekR, cheekL).normalize();
                        const verticalVec = new THREE.Vector3().subVectors(forehead, chin).normalize();
                        const faceNormal = new THREE.Vector3().crossVectors(verticalVec, horizontalVec).normalize();
                        
                        leftLaser.visible = true;
                        rightLaser.visible = true;
                        leftLaser.position.copy(leftEyePos);
                        rightLaser.position.copy(rightEyePos);
                        
                        const targetL = leftEyePos.clone().add(faceNormal.clone().multiplyScalar(1000));
                        const targetR = rightEyePos.clone().add(faceNormal.clone().multiplyScalar(1000));
                        leftLaser.lookAt(targetL);
                        rightLaser.lookAt(targetR);

                    } else if (state.currentEffect === 'fire') {
                        leftFlameParticles.visible = true;
                        rightFlameParticles.visible = true;
                        leftFlameParticles.position.copy(leftEyePos);
                        rightFlameParticles.position.copy(rightEyePos);

                    } else if (state.currentEffect === 'tears') {
                        leftTearParticles.visible = true;
                        rightTearParticles.visible = true;
                        leftTearParticles.position.copy(leftTearPos);
                        rightTearParticles.position.copy(rightTearPos);
                    }
                }
            }
        }

        // --- Setup Camera & Mesh ---
        const faceMesh = new FaceMesh({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
        }});

        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        faceMesh.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await faceMesh.send({image: videoElement});
            },
            width: 1280,
            height: 720
        });

        cameraUtils.start().catch(err => {
            console.error(err);
            loadingElement.innerHTML = "Error accessing camera.<br>Please check permissions.";
            loadingElement.style.borderColor = "red";
            loadingElement.style.color = "red";
        });

        // --- UI Controls ---
        toggleBtn.addEventListener('click', () => {
            state.effectEnabled = !state.effectEnabled;
        });

        effectSelector.addEventListener('change', (event) => {
            state.currentEffect = event.target.value;
        });

    </script>
</body>
</html>
